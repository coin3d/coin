If you want to work _with_ the Coin sourcecode (not just writing
applications _using_ the Coin library) -- for helping us fixing bugs,
improve performance, or whatever reasons -- this file contains some
hints and tips for you.

==============================================================================

1 The Bleeding Edge
===================

First of all, you should make sure you are building from the latest
sources from the CVS branch you want to work with. This is done by
using the Concurrent Versioning System for staying in sync with the
sourcecode repository we at Systems in Motion are using. Follow the
instructions on the webpages at <URL:http://www.coin3d.org/>.

Be aware that Coin has two source repositories.  "Coin" is the head
development repository which is unstable and may contain unportable
code and break binary compatibility from time to time.  "Coin-1" is
the repository we release the Coin 1.* releases from and will always
contain stable code that does not break upwards binary compatibility.
You can hack on either, but for your application development efforts'
sake you might want to follow Coin-1.

If you are not familiar with CVS, check out the CVS homepages at
<URL:http://cvshome.org>.


2 Surviving a Large C++ Project
===============================

The main problem all large C or C++ projects bump into sooner or later
is that the turn-around time for doing compile, link and run gets too
long for development to be efficient. When we're talking re-linking of
library files of >30MB (with debug information), its gonna get painful
to do rapid incremental bugfixing / testing cycles.

So I'm going to explain now how we at SIM have (more or less
fundamentally) solved this problem for our core Coin library. First of
all: use a "UNIX-like" system. MSWindows systems are no good for
working with the kind of setup we have, we do all new development on
UNIX systems (mostly Linux and SGI IRIX) and so the build process have
been tuned for these platforms.

A typical set-up session for me for doing Coin development on a virgin
machine looks like this (I'm using SoXt as the GUI library for
demonstration purposes):

  $ cd $HOME
  $ mkdir code compile install
  $ cd code
  $ cvs -z3 -d :pserver:cvs@cvs.sim.no:/export/cvsroot checkout -P simage-1
  [cvs doing its thing]
  $ cvs -z3 -d :pserver:cvs@cvs.sim.no:/export/cvsroot checkout -P Coin-1
  [cvs doing its thing]
  $ cvs -z3 -d :pserver:cvs@cvs.sim.no:/export/cvsroot checkout -P SoXt
  [cvs doing its thing]

        Note: you might want to work with a particular branch from the
        CVS, if so use the "-r" option to the "cvs checkout"s above.

        Note2: if you have already checked out the sources at an
        earlier point in time, you just ``cd'' to the sourcecode
        directories and do

                $ cvs -z3 -q update -dP

        instead of the full checkout.


  $ cd $HOME/compile
  $ mkdir simage Coin SoXt

  $ cd $HOME/compile/simage
  $ $HOME/code/simage-1/configure --prefix=$HOME/install
  [configure running]
  $ make install
  [build should complete quickly]

  $ cd $HOME/compile/Coin
  $ $HOME/code/Coin-1/configure --prefix=$HOME/install --enable-hacking
  [configure running]

        Note the "--enable-hacking" option to configure. This is the
        brilliant part. What happens with this option is that instead
        of making one monolithic libCoin.so file, the Coin library
        will be linked into many shared libraries, one for each
        subdirectory under $HOME/compile/Coin/src/. The brilliance of
        this little trick will be explained later in the walk-through.

  $ make install
  [building will take quite some time, go for a coffee]

  $ cd $HOME/compile/SoXt
  $ $HOME/code/SoXt/configure --prefix=$HOME/install
  [configure running]
  $ make install
  [build shouldn't take long]

Ok, that's it. You should now have libsimage, libCoin and libSoXt
built and installed under $HOME/install/lib/.

If you go look in the $HOME/install/lib/ directory, you will see a
bunch of files named lib**something**LINKHACK.so. For each of the
"submodules" in Coin where you will be working, you should now remove
the relevant .so-files and instead symlink them directly from the
build directory. I.e., if you are going to work with the node classes,
execute the following:

  $ cd $HOME/install/lib
  $ ls -c1 *nodesLINKHACK*
  libnodesLINKHACK.la*
  libnodesLINKHACK.so@
  libnodesLINKHACK.so.0@
  libnodesLINKHACK.so.0.0.0*
  $ rm libnodesLINKHACK.so.0.0.0
  $ ln -s $HOME/compile/Coin/src/nodes/.libs/libnodesLINKHACK.so.0.0.0 libnodesLINKHACK.so.0.0.0

(The other two .so-files are just symlinks to the .so.0.0.0 file, so
we don't need to do anything about those.)

You should now be able to do development with very short compile &
link turn-around cycles on the classes in the $HOME/code/Coin/nodes/
directory. Each time you have made a change to the sourcecode, just

  $ cd $HOME/compile/Coin/src/nodes
  $ make

Only the relevant .cpp will now be re-compiled and only the
libnodesLINKHACK.so sub-library will be re-linked. And the
libnodesLINKHACK.so in the install directory which client applications
are using is a symlink pointing to the one in your build directory, so
no re-installation need to happen.


One caveat emptor: if any of the class-definitions change in a
non-ABI[1] compatible way in any of the corresponding .h files, you
need to recompile and relink _all_ sourcecode depending on this class,
not just the class itself. Or core dumps will happen.

There are many, many ways to break ABI[1] compatiblity in C++:

  - variables being added or removed from / to a class, making it's
    sizeof() change
  - functions added or removed
  - functions made virtual or "un-made" from virtual
  - function signatures changed in general

  ...etc. See footnote [1] at the end of this document for more
  discussion on the issue. Anyway, as long as you're only changing the
  .cpp files, you should be home free.


Right after we implemented this scheme, there was an article called
"Pseudo-Incremental Linking For C/C++" in the Dr Dobb's Journal. The
article is available at

    <URL:http://www.ddj.com/articles/1999/9910/9910d/9910d.htm>

and explains the principles applied fairly well.


3 Debugging Tricks
==================

* COIN_DEBUG_BREAK

  All calls to SoDebugError::post*() have the first argument (the
  function name) compared to the $COIN_DEBUG_BREAK environment variable.
  If they match, an assert will fail, and you can then inspect the stack
  backtrace (if symbol/debugging information was built into the library).
  This can be very useful and is not limited to Coin usage - all client
  programs can take advantage of this functionality too.

  Example:

    $ env COIN_DEBUG_BREAK="SoAction::apply" ./mytestprogram

  [using 'env var=val prog ...' is the most portable syntax for this kind
  of thing, which is why the example uses it instead of the Bourne syntax]


4 Misc Configurations
=====================

* cvs

  The following lines can be useful to have in your ~/.cvsrc file:

    cvs -q -z3
    diff -u

  Line 1 enables compression and a more quiet operation mode (e.g. no
  listing about subdirs when there are no changes), and line 2 makes
  sure all "cvs diff" commands uses the unified syntax.

* emacs

  To enable C++ mode for the template *.in source files, add this to
  your ~/.emacs file:

    (setq auto-mode-alist (cons '("\\.h\\.in\\'" . c++-mode) auto-mode-alist))
    (setq auto-mode-alist (cons '("\\.cpp\\.in\\'" . c++-mode) auto-mode-alist))

  Also, to make emacs insert spaces instead of tabulator characters when
  indenting (we don't want any tabulators):

    (let ((loadhook (lambda () (setq indent-tabs-mode nil))))
      (add-hook 'find-file-hooks loadhook)
      (add-hook 'find-file-not-found-hooks loadhook))


5 The Build Environment
=======================

* Defines

  HAVE_CONFIG_H

    This define should always be defined, but if it isn't, then the
    config.h header will not be included.  Lots of features will then be
    disabled.  Lots of files will probably not even compile since we do
    not test this case.  Anyways, this case is usually the case when
    someone tries building the library without using the Autoconf setup.

  COIN_INTERNAL

    This is a define that is set when the Coin library is being compiled.
    Setting it when compiling things outside the Coin library is a
    mistake.

  COIN_DEBUG

    This define should be set to either 0 or 1.  It is therefore used
    with the #if directive, not the #ifdef directive.  Actually, this define
    is now preferrably used as an if-condition to avoid littering the source
    code with too many preprocessing directives.

  COIN_EXTRA_DEBUG

    This define is ordinarily not used, but can be defined to enable some
    extra sanity checks that may detect obvious, but otherwise hard to
    detect bugs like specifying indexes out of an arrays range, etc.
    Enabling this define may slow things down considerably, depending on
    how heavily the parts of Coin you use most are instrumented.


6 The Run-Time Environment
==========================

To enable the experimental support for display list caching, set the
environment variable COIN_RENDER_CACHING to "1" and the renderCaching
field of SoSeparator nodes to ON.


7 How To Add / Modify A Class In Coin
=====================================

  * Implement the class.

  * Write Doxygen documentation for the class. Remember to tag the doc
    with \since YYYY-MM-DD, either for the class itself or for any
    functions with a new or changed API.

  * Update cross-references from other documentation if necessary.

  * If new source files were introduced:

        * Add them to the CVS repository.

        * Add the header and any generated doc files for the class to
          build/coin.spec.in (for RPM generation).

        * Add the source files to docs/coin.doxygen.in (for
          documentation generation).

        * If we are a subtype of SoBase, update the correct files for
          initializing the class (i.e. src/nodes/SoNode.cpp).

        * Add the source files to the corresponding all.cpp file.

        * Add the header file to the corresponding common include file
          (i.e. include/Inventor/nodes/SoNodes.h)

        * Add the source files to the Makefile.am file in the source
          file directory (for building).

        * If the class is public, add the header file to
          src/Makefile.am or any of src/*/Makefile.am (for
          installation).

        * Remember to rerun bootstrap when changing any
          Makefile.am. You need to have the correct versions of the
          Autotools (Autoconf, Automake and Libtool -- see the
          bootstrap script for which versions are needed), so it may
          be easier to do this on our internal development
          "repository" for the Autotools; nfs.trh.sim.no.


8 How To Backport Development-Branch Extensions to Coin-1
=========================================================

You can not break forward ABI compatibility with earlier versions of
Coin-1 when you backport extensions added to the Coin development branch.
Virtual methods is one of the biggest problems with regards to this.

* Backporting Virtualism

  If you need to packport virtualism from Coin to Coin-1, one suggestion
  is to add a non-virtual callback handler system on the lowest level in
  the class hierarchy that needs this virtual function, and then the
  deriving classes can register their overriding functions in the
  constructor.  If they need to emulate invoking the inherited::*
  function, they must of course store the callback/closure pair locally in
  the class (private part) that was already set by the parent class when
  they register the overriding function.


=======================================================================
XXX FIXME: complete doc. XXX

* Building Coin for development (UNIX)
        - solutions applied in Coin
                o make install-data
                o make *-am

* Differences, MSWin

* Build hacking, bootstrap/Autoconf/Automake/Libtool

* Submitting patches
        - technical walk-through
        - legal aspects

==============================================================================

The following text pertains to the versioning that is set up in configure.ac
(configure.in).

Library versioning
==================

When making releases, we follow these rules:

* if there has been made any incompatible changes to the ABI[1]:
    COIN_MAJOR_VERSION += 1,
    COIN_MINOR_VERSION = 0,
    COIN_MICRO_VERSION = 0.

   (If you don't know if the changes that have been made since last
   release is binary incompatible with the last ABI, you shouldn't
   be making releases.)

* if there has been made additions to the API[2], but the ABI
  is still backwards compatible: COIN_MAJOR_VERSION unchanged,
  COIN_MINOR_VERSION += 1, COIN_MICRO_VERSION = 0.

* for bugfix releases and other changes which do not change the interface
  at all, keep COIN_MAJOR_VERSION and COIN_MINOR_VERSION unchanged
  and COIN_MICRO_VERSION += 1.


Note that our MAJOR.MINOR.MICRO versioning scheme differs somewhat from
the idea of library versioning applied by Libtool. According to Libtool,
libraries should be versioned according to a CURRENT.AGE.REVISION scheme.
Here CURRENT is supposed to be increased by 1 each time the API changes,
and AGE increased by 1 along with CURRENT each time the API changes in a
way which keeps the ABI backwards compatible. If compatibility is broken,
AGE is set to 0 (while CURRENT is still increased by 1). The REVISION
number has the same semantics as our MICRO number.

To cooperate in a painless way with Libtool, we choose to "convert" our
MAJOR.MINOR.MICRO scheme to Libtool's idea of versioning like this:

* Libtool's CURRENT number is increased when the MAJOR or MINOR number is
  changed.  If development and realeases were dune in a linear fashion, we
  would just have to increase CURRENT by one when the above happens, but
  since we intend to continue to support Coin 1.* after the release of
  Coin 2.* we have had to make up a different scheme.  What we have done is
  to reserve room for 20 minor releases between each major release.  This
  should hopefully be more than enough.  With this premise, we can calculate
  CURRENT with the formula MAJOR * 20 + MINOR.  This will ensure that
  CURRENT for 2.0 will be greater than CURRENT for 1.3 (and 1.17 for that
  matter).

  Note that this scheme has the "strange" (it's actually completely natural)
  effect that Coin 1.0 will be found as /usr/local/lib/libCoin.so.20.*
  (for Linux) and Coin 2.0 will be libCoin.so.40.*.

* Libtool's AGE number is the number of previous CURRENT version numbers
  that the library is binary compatible with.  This should always be the same
  number as MINOR is - when we make a new release with a new MAJOR number
  and 0 as MINOR number, ABI compatibility *will* be broken.

* Libtool's REVISION number is the number of the release with the exact same
  API/ABI as the previous release.  This is typical for patch-releases
  where some implementation bugs are fixed without touching anything in the
  library API.  In other words, when we up the MICRO number.  This means
  REVISION = MICRO.

==============================================================================

CVS maintenance
===============

New "Coin-MAJOR" repositories will be branched off the head "Coin" repository.
When this happens, the Coin repository will be tagged with the symbolic name
"coin-MAJOR_0_0".

All releases will be made from the Coin-MAJOR repositories.  When a new
release is made from one of those, the sources will be tagged with the
symbolic name "coin-MAJOR_MINOR_MICRO".  This was forgotten for the
Coin-1.0.0 release, but for MAJOR.0.0 releases this is not very important
as it will coincide with the initial import of the repository.

Releases made from Coin-MAJOR repositories will be in sequence.  When the
MINOR version number is increased, no more releases of the MINOR - 1 branch
will be made.


Making Releases
===============

When a new release is to be made, configure.ac must be updated with new
version information.  Make sure COIN_BETA is set to [] (empty), and the
release version number is set up.  Run bootstrap and check that
"make distcheck" works.  Commit the changes with a message about setting
the version number to MAJOR.MINOR.MICRO.

Add a CVS tag on the new version number.
  $ cvs tag coin-MAJOR_MINOR_MICRO

Edit configure.ac again and increase micro (unless a new minor will be the
next release) and set COIN_BETA to [a].  Rerun bootstrap, and commit the
new setup with a message about setting the version number again.

These two version-increment commits should happen without getting any
unrelated commits inbetween them so there won't be multiple states of
the CVS repository with a release version number.

Then go back to the tag (update -dP -r coin-MAJOR_MINOR_MICRO) and
prepare the release.

Source release tarballs are created with "make dist".  Binary releases are
created from the source release tarball.


Correcting Erroneous Log Messages
=================================

Sometimes commits end up with incorrect log messages.  It can be fixed with
this command:

  $ cvs admin -m<rev>:<new log message> <file>

Do this instead of reversing and reapplying or other roundabout and
confusing techniques...


==============================================================================

Coin Code Standards
===================

The main goal is of course to write good, bugfree, portable C++ code,
in a way that clearly expresses the intent of what is attempted
accomplished.

Some specific remarks about portability: this is very far from being a
trivial matter with C++, as not only is system portability difficult
(due to differences in core libraries for various platforms), but
_compiler_ portability is also a big issue with C++. The main reason
behind this is that the ISO C++ standard evolved gradually and slowly,
and many C++ compilers that are still around on much used platforms
were written before the standard was complete. And even today, it is
actually doubtful if any C++ compiler around implements the full
standard, as it is so huge and complex.

To keep everything as portable as possible, we basically use the C++
language as more or less a "C with classes".

For the full monty on C++ portability, please read the C++ portability
guide written for the Mozilla browser project:

        <URL:http://www.mozilla.org/hacking/portable-cpp.html>

We consider this a must read for any internal resources writing
production C++ code. One issue it's particularly easy to "sin" against
is the following:

  * Use the ``SbBool'' type instead of bool, and ``TRUE'' and
    ``FALSE'' keywords instead of ``true'' and ``false''. Compilers
    that do not support the ``bool'' type is still in widespread use
    (SGI MIPSPro v7.30 is but one example), so we are using the more
    portable ``SbBool'' instead to make sure our code build on those
    systems.


Enough about the larger issues, now for the mucky details that has
been written down to guide the Coin programmers in being consistent
versus the code "layout" (to make it more easily readable):

 0) If the code you write is not 100% complete;

    - Leave a "FIXME" message if you believe the code is fairly
      correct, but you are unsure and have not checked the correctness
      yet, or if there are known deficiencies. This includes cases
      like ambiguities in the OIV docs that will require some
      investigation to resolve, error-cases or places where one should
      be more robust that haven't been fixed yet due to time
      constraints, etc.

    - Insert "COIN_STUB();" statements if the code lacks certain
      important functionality, so situations where unimplemented
      features are used will be detected at run-time.

    - Leave FIXMEs if you see obvious cases for performance
      improvements which should be explored.

    A FIXME-message must include a description of the problem, who
    wrote the message, and when.  Please include whatever you have
    already found out about the problem in the FIXME text, so your
    next of kin don't have to painstakingly re-do all the thought-work
    you already have laid down.  Example:

    // FIXME: should be possible to simplify cylinder test, since this
    // cylinder is aligned with the y-axis. 19991110 pederb.

    or

     // FIXME: this looks wrong, shouldn't we rather reset the
     // alignment value to what it was previously?  20010824 mortene.

    This goes also for other keywords in comments (see below).  It
    makes it much easier when others try to fix code that doesn't
    work.  You will know who to ask if you don't understand the
    problem, and the date could indicate among other things the
    urgency of the problem.
 
 1) If blocks of code are commented out (obsoleted) to make place for
    new code, or because it has become superfluous, one should mark it
    like the example below if it is a large block of code, if the new
    code is very experimental, or if the new code is obfuscated
    (e.g. because of optimizations).

    #if 0// OBSOLETE: <textual description>. <yyyymmdd userid>.
    ...old code...
    #else // short description of new code
    ...new code...
    #endif // newcode

    See also the next rule.

 2) Under *no* circumstances should developers leave any code which
    has been commented out with the language constructs "// ..." or
    "/* ... */" in anything you check into CVS, at least not without
    commenting _why_ the code is still present.

    It's often very time-consuming and just a bloody pain in the ass
    and a waste of resources trying to figure out why commented-out
    code is still present in a source file (is it new code which
    *might* fix a bug, but which haven't been tested yet?  is it old
    code found to be buggy which have been removed? is it commented
    out because it is a new feature which is yet to be completed? etc
    etc etc).

    Programmers who sin against this rule should be taken out behind
    the barn to be shot.

 3) During debugging, write debug code like this:

    #if COIN_DEBUG && 1 // debug
      SoDebugError::postInfo(...
    #endif // debug

    Then, flip the "#if COIN_DEBUG && 1" to "#if COIN_DEBUG && 0" if
    there is a chance that the debug information might be useful
    later.  If not, remove it before making a patch or checking in.

    If there are many debug statements in the same category, use a
    define for that category (#if DEBUG_<category>) and define it to 0
    at the top of the file before checking in the code.  See
    src/sensors/SoSensorManager.cpp for examples of how this should be
    done.

    UPDATE 2001-11-21 larsa: Actually, we now prefer that you use this
    define as an if-condition instead, because of the cleaner look the
    source code gets when it is not littered with preprocessing
    directives.  For permanent debugging code, write therefore source
    code like this instead:

    if ( COIN_DEBUG ) {
      SoDebugError::postInfo("SoDB::funnyRabbit", "follow the white rabbit");
    }

 4) Do not under any circumstances use printf() / fprintf() / puts()
    or related functions for output.  It should not be necessary --
    the Coin class SoDebugError (and SoReadError) was implemented for
    a reason.  Debug messages with printf() / fprintf() is extremely
    uncool when you use Coin as a DLL under Windows (it's likely to
    cause mysterious crashes), and besides it's bloody irritating to
    walk through the code later to remove them.

 5) Don't use any variablename, classname, define, functionname or any
    other identifier that starts with an underscore. That namespace is
    per the C and C++ specs fully reserved for the compiler.

 6) Code formatting rules. The default is to use Kernighan and Ritchie style.

   a) Braces: keep opening braces on the end of the line, and closing
      braces at the start. Like this:

      if (...) {
        ...
      }

      And not like this:

      if (...)
      {
        ...
      }

      The exception from this rule is functions, which should have the
      opening brace on the next line.

   b) Indentation: use 2 spaces extra for each level of nesting.
      *Never* use tabulator characters (ie ASCII code 0x09).

   c) Spacing: use 1 space after commas and around operators (like +,
      -, *, /, ==, &&, etc), but not after or before parentheses.

      Like this:

      if (val) { i = sqrt(a) * func(b, c); }

      Not like this:

      if ( val ) { i=sqrt(a)*func(b,c); }

   d) Naming: class names should be uppercased for each word, function
      names for each word except the first one, variable names should
      be all lowercase, and defines, enums and constants should be all
      uppercase. Example:

      float
      MathClass::calculateValue(float in)
      {
        const float FACTOR = 2.78;
        ...
        ...
      }

   e) Pointer types and references: use a space on each side of the
      '*' and '&' operators, like this

        SoNode * mynode = NULL;

      not like this

        SoNode *mynode = NULL;

      because it makes it look like the '*' "belongs" to the variable
      name (which of course is wrong -- it's part of the type), and
      not like this either

        SoNode* mynode = NULL;

      because it's ugly and unusual. So for consistency, _please_
      stick with the space-on-both-sides convention in Coin code.

==============================================================================

API Documentation Guidelines
============================

Documentation of the Coin API is done with a setup and syntax
compatible with the Doxygen tool. For general information and detailed
documentation about the Doxygen syntax, see
<URL:http://www.doxygen.org>.

We allow documentation to be done in a rather free-form manner, as
long as it conforms to the valid syntax of Doxygen. There is basically
just one rule which is an absolute must:

        * New functions and classes in the API have to be tagged with
          "\since", to make it possible for application programmers to
          know when the API was extended -- in case they want to
          support a range of older versions of the library, for
          instance. Valid parameters to "\since" are:
          * Coin x.y              - What Coin version it first occured in.
          * TGS Inventor x.y[.z]  - What TGS OIV version it first occured in.
          * Inventor x.y[.z]      - What SGI OIV version it first occured in.
          * YYYY-MM-DD            - What date it was added to Coin. Will be 
                                    converted to the correct COIN-x.y for each 
                                    Coin release.
          Use ',' as a separator if more than one implementation supports
          the extension. If an extension is introduced in two branches of 
          Coin, tag both in cases as (COIN-1.1, COIN-2.1) but only once if 
          you mean COIN-1.1 and later (e.g. all 2.x releases support the 
          extension). The z release numbers should normally never be used
          as adding features between patchlevel releases would break binary
          compatibility, but at least TGS is known to break this "rule".

Other than this, use your common sense and look at the already
existing documentation that is available.

A few hints:

        * We never started using the common "JavaDoc"-style way of
          forcing tags and documentation on all arguments and return
          types with "\param" and "\return" -- so there's no point in
          doing that for the functions you write.

        * Cross-reference to other functions and / or classes with the
          "\sa" ("see also") tag where it seems helpful for the
          application programmer. Remember that Doxygen automatically
          finds and crossreferences class or function names found in
          the doc anyway, so don't overuse the "\sa" tag.

        * We do not force a third-person vs an imperative style, or
          vice versa. Use the same style as "nearby" documentation.

        * Make sure *all* important aspects of a class or a function
          is documented properly -- _don't_ expect the application
          programmer to ever having to resort to the header files or
          implementation sourcecode.


==============================================================================

Footnotes
=========

[1] Application Binary Interface. This covers any publicly exposed
    functions, function signatures, structures (and classes for C++
    code). If any functions has been removed or changed, or if any
    structures/classes has been modified in any way, the ABI has most
    likely been made incompatible with earlier releases.

    For a more comprehensive list of what breaks ABI compatibility
    under C++, see the technical FAQ for Troll Tech' Qt library. Last
    seen here: <URL:http://www.trolltech.com/developer/faqs/technical.html>.
    (It's the "You frequently say that you cannot add this or that
    feature because it would break binary compatibility. What does
    this mean, really?" question.)

[2] Application Programmer's Interface. This is the functions and data
    structures/classes exposed to the application programmer for
    interaction with the library.

==============================================================================
