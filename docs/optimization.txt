============================================================================

General guidelines:
===================

  * levels of optimization (sorted in order of impact):

        i) asymptotic algorithm time (list traversal, sorting, etc)

       ii) caching strategies (and implementations)

      iii) low-level stuff (piping data to OpenGL, inlining of
           functions, etc)

     i) should be more-or-less ok in Coin. There are major tasks at
     ii), particularly in the SoSeparator implementation. The obvious
     stuff at iii) is in the Sb* classes; SbVec3f, SbMatrix etc, but
     we need decent profiling to expose the bottlenecks.

     One important thing to note about case iii) is the fact that we
     should _really_ have some kind of regression testing system in
     place before we start optimization of the basic classes, to avoid
     introducing hard-to-find bugs.


  * tasks for optimizations:
        0) try to single out interesting areas for profiling

        1) make a good test case for one particular area
        2) optional: show us the testcode for approval & feedback
        3) do extensive profiling
        4) analyze results
        5) optional: present them for sanity checking
        6) optimize
        7) submit fixes as patches 
        8) goto 1

    About step 1): it would be good to make testcases which could be
    made permanent for routine checks on the performance. Maybe we
    could even automate this with the aid of one of the tools from the
    Mozilla project?

  * interesting areas to fix (roughly in sorted order):

        - traversal in general, rendering and picking in particular
          ("optimization-by-caching") -- this is first priority

        - file import / parsing (and export?)

        - startup-time (for instance measured for the
          examples/components/examinerviewer executable)

        - user interaction through draggers & manipulators, must
          secure decent responsiveness

============================================================================

Concrete tasks:
===============

        * implement a framerate counter in the So*ExaminerViewer, to
          make it easier to get a "feeling" on which scenes / shapes /
          whatever that have bad rendering performance

        * SoSeparator is missing these caching and exclusion
          mechanisms:

                - rendercaching (with OpenGL renderlists)
                - viewfrustum culling when rendering
                - viewfrustum culling when picking

          ..and in addition we've not yet implemented any heuristics
          on the "AUTO" setting for caching (so far, we only do
          bounding box caching) -- we just default to "ON", which can
          be _very_ lousy behaviour with regards to performance.

        * from a quick peek at the code, it looks like
          SoMField-derived classes calls (or may call) valueChanged()
          multiple times from certain functions

        * trace the notification mechanisms to see if we send
          superfluous notification messages (field->field,
          field->node, node->node, ...)

        * SoTabBoxDragger rendering seems particularly slow on my PII
          266MHZ laptop -- why? The dragger geometry looks simple
          enough, and draggers with more complex geometries seems to
          render with far better performance.

============================================================================
