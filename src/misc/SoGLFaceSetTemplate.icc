/**************************************************************************\
 *
 *  This file is part of the Coin 3D visualization library.
 *  Copyright (C) 1998-2001 by Systems in Motion.  All rights reserved.
 *  
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License
 *  version 2 as published by the Free Software Foundation.  See the
 *  file LICENSE.GPL at the root directory of this source distribution
 *  for more details.
 *
 *  If you desire to use Coin with software that is incompatible
 *  licensewise with the GPL, and / or you would like to take
 *  advantage of the additional benefits with regard to our support
 *  services, please contact Systems in Motion about acquiring a Coin
 *  Professional Edition License.  See <URL:http://www.coin3d.org> for
 *  more information.
 *
 *  Systems in Motion, Prof Brochs gate 6, 7030 Trondheim, NORWAY
 *  <URL:http://www.sim.no>, <mailto:support@sim.no>
 *
\**************************************************************************/

(const SoGLCoordinateElement * const vertexlist,
 const int32_t *vertexindices,
 int numindices,
 const SbVec3f *normals,
 const int32_t *normalindices,
 SoMaterialBundle *materials,
 const int32_t *matindices,
 const SoTextureCoordinateBundle * const texcoords,
 const int32_t *texindices)
{
  int texidx = 0;

  const SbVec3f * coords3d = NULL;
  const SbVec4f * coords4d = NULL;
  const SbBool is3d = vertexlist->is3D();
  if (is3d) {
    coords3d = vertexlist->getArrayPtr3();
  }
  else {
    coords4d = vertexlist->getArrayPtr4();
  }

  // This is the same code as in SoGLCoordinateElement::send().
  // It is inlined here for speed (~15% speed increase).
#define SEND_VERTEX(_idx_) \
  if (is3d) glVertex3fv((const GLfloat*) (coords3d + _idx_)); \
  else glVertex4fv((const GLfloat*) (coords4d + _idx_));

  int mode = GL_POLYGON; // ...to save a test
  int newmode;
  const int32_t *viptr = vertexindices;
  const int32_t *viendptr = viptr + numindices;
  int32_t v1, v2, v3, v4, v5 = 0; // v5 init unnecessary, but kills a compiler warning.
  SbVec3f dummynormal(0,0,1);

#if NBINDING==PER_VERTEX || NBINDING==PER_FACE || NBINDING==PER_VERTEX_INDEXED || NBINDING==PER_FACE_INDEXED || TEXTURES==TRUE
  const SbVec3f *currnormal = &dummynormal;
  if (normals) currnormal = normals;
#endif // currnormal wrapper

  int matnr = 0;

  while (viptr + 3 < viendptr) {
    v1 = *viptr++;
    v2 = *viptr++;
    v3 = *viptr++;
    if (v1 < 0 || v2 < 0 || v3 < 0) {
#ifdef COIN_DEBUG
      SoDebugError::postWarning("[faceset]::GLRender",
                                "Polygon with less than three vertices detected. "
                                "(First 3 indices are: <%d, %d, %d, ...>.) "
                                "Rendering aborted for current shape.",
                                v1, v2, v3);
#endif // COIN_DEBUG
      break;
    }
    v4 = *viptr++;
    if (v4  < 0) newmode = GL_TRIANGLES;
    else {
      v5 = *viptr++;
      if (v5 < 0) newmode = GL_QUADS;
      else newmode = GL_POLYGON;
    }
    if (newmode != mode) {
      if (mode != GL_POLYGON) glEnd();
      mode = newmode;
      glBegin((GLenum) mode);
    }
    else if (mode == GL_POLYGON) glBegin(GL_POLYGON);

    /* vertex 1 *********************************************************/
#if MBINDING==PER_VERTEX || MBINDING==PER_FACE
    materials->send(matnr++, TRUE);
#elif MBINDING==PER_VERTEX_INDEXED || MBINDING==PER_FACE_INDEXED
    materials->send(*matindices++, TRUE);
#endif
#if NBINDING==PER_VERTEX || NBINDING==PER_FACE
    currnormal = normals++;
    glNormal3fv((const GLfloat*)currnormal);
#elif NBINDING==PER_VERTEX_INDEXED || NBINDING==PER_FACE_INDEXED
    currnormal = &normals[*normalindices++];
    glNormal3fv((const GLfloat*)currnormal);
#endif
#if TEXTURES==TRUE
    texcoords->send(texindices ? *texindices++ : texidx++,
                    vertexlist->get3(v1),
                    *currnormal);
#endif
    SEND_VERTEX(v1);

    /* vertex 2 *********************************************************/
#if MBINDING==PER_VERTEX
    materials->send(matnr++, TRUE);
#elif MBINDING==PER_VERTEX_INDEXED
    materials->send(*matindices++, TRUE);
#endif
#if NBINDING==PER_VERTEX
    currnormal = normals++;
    glNormal3fv((const GLfloat*)currnormal);
#elif NBINDING==PER_VERTEX_INDEXED
    currnormal = &normals[*normalindices++];
    glNormal3fv((const GLfloat*)currnormal);
#endif
#if TEXTURES==TRUE
    texcoords->send(texindices ? *texindices++ : texidx++,
                    vertexlist->get3(v2),
                    *currnormal);
#endif
    SEND_VERTEX(v2);

    /* vertex 3 *********************************************************/
#if MBINDING==PER_VERTEX
    materials->send(matnr++, TRUE);
#elif MBINDING==PER_VERTEX_INDEXED
    materials->send(*matindices++, TRUE);
#endif
#if NBINDING==PER_VERTEX
    currnormal = normals++;
    glNormal3fv((const GLfloat*)currnormal);
#elif NBINDING==PER_VERTEX_INDEXED
    currnormal = &normals[*normalindices++];
    glNormal3fv((const GLfloat*)currnormal);
#endif
#if TEXTURES==TRUE
    texcoords->send(texindices ? *texindices++ : texidx++,
                    vertexlist->get3(v3),
                    *currnormal);
#endif
    SEND_VERTEX(v3);

    if (mode != GL_TRIANGLES) {
      /* vertex 4 (quad or polygon)**************************************/
#if MBINDING==PER_VERTEX
      materials->send(matnr++, TRUE);
#elif MBINDING==PER_VERTEX_INDEXED
      materials->send(*matindices++, TRUE);
#endif
#if NBINDING==PER_VERTEX
      currnormal = normals++;
      glNormal3fv((const GLfloat*)currnormal);
#elif NBINDING==PER_VERTEX_INDEXED
      currnormal = &normals[*normalindices++];
      glNormal3fv((const GLfloat*)currnormal);
#endif
#if TEXTURES==TRUE
      texcoords->send(texindices ? *texindices++ : texidx++,
                      vertexlist->get3(v4),
                      *currnormal);
#endif
      SEND_VERTEX(v4);
      if (mode == GL_POLYGON) {
      /* vertex 5 (polygon) ********************************************/
#if MBINDING==PER_VERTEX
        materials->send(matnr++, TRUE);
#elif MBINDING==PER_VERTEX_INDEXED
        materials->send(*matindices++, TRUE);
#endif
#if NBINDING==PER_VERTEX
        currnormal = normals++;
        glNormal3fv((const GLfloat*)currnormal);
#elif NBINDING==PER_VERTEX_INDEXED
        currnormal = &normals[*normalindices++];
        glNormal3fv((const GLfloat*)currnormal);
#endif
#if TEXTURES==TRUE
        texcoords->send(texindices ? *texindices++ : texidx++,
                        vertexlist->get3(v5),
                        *currnormal);
#endif
        SEND_VERTEX(v5);
        v1 = *viptr++;
        while (v1 >= 0) {
      /* vertex 6-n (polygon) *****************************************/
#if MBINDING==PER_VERTEX
          materials->send(matnr++, TRUE);
#elif MBINDING==PER_VERTEX_INDEXED
          materials->send(*matindices++, TRUE);
#endif
#if NBINDING==PER_VERTEX
          currnormal = normals++;
          glNormal3fv((const GLfloat*)currnormal);
#elif NBINDING==PER_VERTEX_INDEXED
          currnormal = &normals[*normalindices++];
          glNormal3fv((const GLfloat*)currnormal);
#endif
#if TEXTURES==TRUE
          texcoords->send(texindices ? *texindices++ : texidx++,
                          vertexlist->get3(v1),
                          *currnormal);
#endif
          SEND_VERTEX(v1);
          v1 = *viptr++;
        }
        glEnd(); /* draw polygon */
      }
    }
#if MBINDING==PER_VERTEX_INDEXED
    matindices++;
#endif
#if NBINDING==PER_VERTEX_INDEXED
    normalindices++;
#endif
#if TEXTURES==TRUE
    if (texindices) texindices++;
#endif
  }
  // check if triangle or quad
  if (mode != GL_POLYGON) glEnd();
}

#undef SEND_VERTEX
