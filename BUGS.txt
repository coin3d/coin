 =====================================================================

002 Trying to parse this file causes an assert failure / crash (which
    should _never_ happen, of course, no matter how wrong the file
    is):

    ---8<-------8<-------8<-------8<-------8<-------8<-------8<----
    #Inventor V2.1 ascii

    Separator {
       TransformerDragger {
          translator1Switch Switch { }
          translator1LocateGroup LocateHighlight { }
       }
    }
    ---8<-------8<-------8<-------8<-------8<-------8<-------8<----

    => /home/mortene/code/coin-head/src/nodekits/SoBaseKit.cpp:1686:
         SbBool SoBaseKit::setPart(int, SoNode *):
         Assertion `oldIdx >= 0' failed.

    (After this has been fixed, should also try to fully export the
    internals of an unmodified SoTransformerDragger and then read it
    back in again, as the file above is a _very_ cut-down version of
    such a dump.)

    <mortene@sim.no> 20020205.

    UPDATE: A probable cause-effect relationship is found: When a
    Switch field and one or all of it's children is specified in the
    iv-file, the assert is hit. Any other combination of specification
    in the IV file misses the assert.(e.g. Specify just the switch, or
    any or all of the children without specifying the parent
    switch). This behaviour is documented thorougly in
    Flip/src/Inventor/input.cpp. Needs further investigation to find
    exact cause and fix. (When I say 'probable' it's because I have
    not implemented a do-nothing NodeKit with a Switch with children
    as 'proof' yet) 20021031 rolvs

    UPDATE: some additional information on this; I'm not sure it
    should really be allowed to specify any dragger internals in an
    .iv-file -- I _believe_ draggers are supposed to be just
    black-boxes in those circumstances. pederb might have more info on
    that. If my assumption is correct, that would affect what kind of
    fix to make for this. 20021031 mortene.

    UPDATE: According to pederb this came from the assumed OIV-bug
    where a dump of a scenegraph from OIV2.1 exports private elements
    of the draggers to the file - Coin don't do that any more. The
    scenegraph described abowe now writes out as:

    --------------------
    #Inventor V2.1 ascii


    Separator {

    TransformerDragger {
    }}
    --------------------

    The message displayed could be more informative though, and
    perhaps this kind of malformed input should be trapped earlier and
    reported as a read-error. 20021104 rolvs

    UPDATE 20021104 mortene: it should *absolutely* be caught and
    trigger a read-error and bail out. As is said right at the
    beginning of this bug-report, Coin should *never* fail by crashing
    for malformed input files -- that would cause major headaches for
    those who want to have a robust client application.

=====================================================================

003 There are seams in texturemaps on SGI Octane with "IMPACTSR"
    graphics hardware.

    Can at least be seen on the SoGuiExamples/nodes/texture
    example. Reported by Dan Stewart on coin-discuss. Cause not yet
    known. Hard to debug and fix without access to the platform in
    question.

    <mortene@sim.no> 20020205.

=====================================================================

005 Free memory read on connected SoSFEnum fields?

    This is an old problem which might have been fixed now, but we
    should check it with Valgrind: Purify used to report "Free memory
    read" when deleting SoSFEnum fields that were connected to other
    fields.

    <mortene@sim.no> 20020521.

=====================================================================

007 For the following stand-alone example, picking on the nurbscurve
    only partly works:

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---
    #include <Inventor/SoDB.h>
    #include <Inventor/SoInput.h>
    #include <Inventor/SoPickedPoint.h>
    #include <Inventor/events/SoLocation2Event.h>
    #include <Inventor/nodes/SoBaseColor.h>
    #include <Inventor/nodes/SoCone.h>
    #include <Inventor/nodes/SoCoordinate3.h>
    #include <Inventor/nodes/SoEventCallback.h>
    #include <Inventor/nodes/SoMarkerSet.h>
    #include <Inventor/nodes/SoSeparator.h>
    #include <Inventor/Qt/SoQt.h>
    #include <Inventor/Qt/viewers/SoQtExaminerViewer.h>

    SoCoordinate3 *coord;

    void mouseMoveCB(void *userData, SoEventCallback *eventCB)
    {
      const SoPickedPoint *pickP = eventCB->getPickedPoint();
      if(pickP){
        const float *xyz = pickP->getPoint().getValue();
        printf("xyz =%lf %lf %lf\n",xyz[0],xyz[1],xyz[2]);
        coord->point.setValue(xyz);
      }
    }

    const char * nurbscurve = "#Inventor V2.1 ascii\n\n"
    "Separator {"
    "   PickStyle {"
    "      style SHAPE"
    "   }"
    "   LightModel {"
    "      model BASE_COLOR"
    "   }"
    "   Coordinate3 {"
    "      point [ 1476.11 1460.84 -628.038,"
    "       1470.86 1447.8 -622.961,"
    "       1462.15 1424.9 -613.788,"
    "       1452.31 1396.07 -601.719,"
    "       1443.57 1368.74 -589.954,"
    "       1428.74 1318.74 -567.739,"
    "       1399.1 1199.31 -510.515,"
    "       1380.47 1084 -445.435,"
    "       1366.84 973.854 -378.304,"
    "       1361.86 927.129 -348.91,"
    "       1356.41 868.655 -311.219,"
    "       1351.93 814.353 -275.603,"
    "       1347.16 745.613 -229.666,"
    "       1342.98 674.034 -181.29,"
    "       1339.84 614.017 -140.592,"
    "       1336.44 546.811 -95.1583,"
    "       1331.26 446.458 -27.7185,"
    "       1321.74 299.504 68.5609,"
    "       1306.62 162.637 153.404,"
    "       1290.91 63.5896 211.906,"
    "       1276.65 -13.3307 256.203,"
    "       1255.13 -107.653 308.474,"
    "       1222.55 -219.064 367.003,"
    "       1195.21 -292.713 403.659,"
    "       1180.26 -329.3 421.348 ]"
    "   }"
    "   NurbsCurve {"
    "      numControlPoints 25"
    "      knotVector [ 0, 0, 0, 0,"
    "       0.0212654, 0.0372336, 0.0466221, 0.0653992,"
    "       0.117887, 0.239617, 0.255294, 0.302551,"
    "       0.318454, 0.354628, 0.395169, 0.43633,"
    "       0.477697, 0.498482, 0.551868, 0.649936,"
    "       0.748818, 0.781971, 0.815122, 0.876749,"
    "       0.938373, 1, 1, 1,"
    "       1 ]"
    "   }"
    "}";


    int
    main(int argc, char ** argv)
    {
      QWidget *window = SoQt::init(argv[0]);

      SoSeparator *root = new SoSeparator;

      //add a green marker to appear under cursor
      SoSeparator *marksep = new SoSeparator;
      root->addChild(marksep);
      SoBaseColor *markColor = new SoBaseColor;
      markColor->rgb.setValue(0,1,0);
      marksep->addChild(markColor);
      coord = new SoCoordinate3;
      marksep->addChild(coord);
      SoMarkerSet *mark = new SoMarkerSet;
      marksep->addChild(mark);
      mark->markerIndex=SoMarkerSet::PLUS_5_5;

      SoEventCallback *myEventCB = new SoEventCallback;
      root->addChild(myEventCB);
      myEventCB->addEventCallback(SoLocation2Event::getClassTypeId(),mouseMoveCB);

      SoInput in;
      in.setBuffer((void *)nurbscurve, strlen(nurbscurve));
      SoSeparator * nurbsep = SoDB::readAll(&in);
      assert(nurbsep);
      root->addChild(nurbsep);

      SoQtExaminerViewer * viewer = new SoQtExaminerViewer(window);
      viewer->setSceneGraph(root);
      viewer->show();
      SoQt::show(window);
      SoQt::mainLoop();
      return 0;
    }
    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---

    (Original test-code supplied by Nigel Murry.)

    Some other specifications for nurbscurves and nurbssurfaces tested
    works correctly.

    pederb has tracked this down to be likely to be caused by bugs in
    libGLU: a rendered curve is different from a tesselated curve (!).

    Hard to solve this *properly* without implementing our own
    nurbs-library, thereby dropping GLU. Are there any quick-fixes we
    could apply?

    <mortene@sim.no> 20020521.

=====================================================================

012 Buglet: the SoMaterial::shininess field is not clamped if it's >
    1.0. This causes OpenGL errors, at least with some drivers.

    (The other material field values are also likely to be able to
    cause problems like this.)

    Consider this bug a low priority item.

    mortene 20020625.

=====================================================================

013 Bounding box calculation of the scenegraph given below is
    sub-optimal.

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---
    #Inventor V2.1 ascii

    Separator {
       Separator {
          Cube { }

          BaseColor { rgb 1 0 0 }
          Translation { translation +4 0 0 }
          Separator {
    	 Transform {
    	    translation 0 -0.5 0
    	    rotation 0 0 1 0.78
    	    scaleFactor 0.5 2 3
    	    scaleOrientation 1 0 0 0.78
    	    center 0.5 0.5 0.5
    	 }
    	 Cube { }
          }
       }

       Translation { translation 0 +6 0 }
       Separator {
          Cube { }

          BaseColor { rgb 1 0 0 }
          Translation { translation +4 0 0 }
          Separator {
    	 Transform {
    	    translation 10 -0.5 0 ~
    	    rotation 0 0 1 0.78
    	    scaleFactor 0.5 2 3
    	    scaleOrientation 1 0 0 0.78
    	    center 0.5 0.5 0.5
    	 }
    	 Cube { }
          }
       }
    }
    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---

    A good opening gambit for investigating the bug is using the
    SoGuiExamples/engines/computexfbox example code to load the scene
    and view the resulting bbox.

    mortene 20020729.

=====================================================================

017 If you drag one of the interaction tabs on an SoTabPlaneDragger
    past the one on the opposite side (that is: so the scaleFactor in
    that direction is close to 0.0), I can see 2 problems which are
    both probably related to the same bug:

        - the geometry "oscillates" around origo as long as the drag
          operation is held

        - if one releases the drag in this position, it's impossible
          to grab one of the tabs again (and the geometry is placed
          wrongly, use "View All" in an examiner viewer to see this)

    For convenience, here's the (trivial) scenegraph one can use to
    reproduce the problem in any viewer component:

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---
    #Inventor V2.1 ascii

    TabPlaneDragger { }
    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---

    I *guess* this should be fixed by placing some lower bound on the
    scalevector values, that somehow matches the lower reaches of
    floating point accuracy that we can still safely use without
    getting the artifacts mentioned above.

    mortene 20020813.

=====================================================================

018 SoTransformerDragger has a bug where the transformation matrix can
    end up with shearing.

    Here's a simple way of reproducing the bug: click and drag the
    middle front rotation point after loading the following scene (and
    changing the viewpoint slightly, so the camera direction is not
    normal to it). Upon releasing the rotation invokation, the
    geometry of the Text3 will be slightly sheared, indicating a
    faulty transform matrix somewhere:

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---
    #Inventor V2.1 ascii

    Separator {
       TransformerManip { }
       Text3 { string "b"   parts ALL }
    }
    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---

    The bug is also listed in the topmost FIXME in
    src/draggers/SoTransformerDragger.cpp, so update that comment
    aswell if you fix the problem.

    mortene 20020813.

=====================================================================

019 When using the CTRL key while doing scaling with
    SoTransformerDragger (to scale against the corner point on the
    opposite side), the geometry will jump by an offset both on
    pushing and releasing the CTRL key.

    For convenience, here's a (trivial) scenegraph to reproduce the
    problem:

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---
    #Inventor V2.1 ascii

    Separator {
       TransformerManip { }
       Text3 { string "b"   parts ALL }
    }
    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---

    This bug basically renders the "CTRL-scaling" feature unusable.

    The bug is also listed in a FIXME near the top in
    src/draggers/SoTransformerDragger.cpp, so update that comment
    aswell if you fix the problem.

    20011208 mortene.

=====================================================================

020 There is a crash bug when changing the parts of an
    SoTransformBoxDragger. It can be reproduced with this stand-alone
    example:

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---
    #include <Inventor/Qt/SoQt.h>
    #include <Inventor/Qt/viewers/SoQtExaminerViewer.h>
    #include <Inventor/draggers/SoTransformBoxDragger.h>
    #include <Inventor/nodes/SoSeparator.h>


    int
    main(int argc, char ** argv)
    {
      QWidget * window = SoQt::init(argv[0]);

      SoTransformBoxDragger * dragger = new SoTransformBoxDragger;

      SbString str;
      for (int i = 1; i <= 6; i++) {
        str.sprintf("translator%d.translator", i);
        dragger->setPart(str.getString(), new SoSeparator);
      }

      SoQtExaminerViewer * viewer = new SoQtExaminerViewer(window);
      viewer->setSceneGraph(dragger);
      viewer->show();
      SoQt::show(window);

      SoQt::mainLoop();

      delete viewer;
      return 0;
    }
    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---

    The bugs pop up at application *exit*, but not every time -- you
    will typically have to try 4 or 5 times to get it to bug out.

    Here's the backtrace from the first indication that something is
    wrong (ie the first SoDebugError posting):

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---
    Coin error in SoChildList::removePathAuditor(): no SoPath 0x80f5fd8 is auditing list 0x80a3038! (of parent 0x80a2b70 (Dragger))
    test: /home/sigma/mortene/code/coin-head/src/errors/SoDebugError.cpp:216: void check_breakpoints(const char *): Assertion `0 && "Coin debug break"' failed.

    Program received signal SIGABRT, Aborted.
    [Switching to Thread 1024 (LWP 2619)]
    0x40d7c9f1 in kill () from /lib/libc.so.6
    (gdb) bt
    [snip]
    #5  0x408cbceb in SoDebugError::post (
        source=0x409d07c0 "SoChildList::removePathAuditor",
        format=0x409d0780 "no SoPath %p is auditing list %p! (of parent %p (%s))")
        at /home/sigma/mortene/code/coin-head/src/errors/SoDebugError.cpp:216
    #6  0x4097bfe5 in SoChildList::removePathAuditor (this=0x80a3038,
        path=0x80f5fd8)
        at /home/sigma/mortene/code/coin-head/src/misc/SoChildList.cpp:364
    #7  0x409bd29f in SoPath::truncate (this=0x80f5fd8, length=0, donotify=1)
        at /home/sigma/mortene/code/coin-head/src/misc/SoPath.cpp:499
    #8  0x409bd1fb in SoPath::truncate (this=0x80f5fd8, length=0)
        at /home/sigma/mortene/code/coin-head/src/misc/SoPath.cpp:473
    #9  0x409bca5b in SoPath::~SoPath (this=0x80f5fd8, __in_chrg=3)
        at /home/sigma/mortene/code/coin-head/src/misc/SoPath.cpp:154
    #10 0x40978786 in SoBase::destroy (this=0x80f5fd8)
        at /home/sigma/mortene/code/coin-head/src/misc/SoBase.cpp:383
    #11 0x40978be5 in SoBase::unref (this=0x80f5fd8)
        at /home/sigma/mortene/code/coin-head/src/misc/SoBase.cpp:501
    #12 0x407a1db7 in SoDragger::~SoDragger (this=0x80a2b70, __in_chrg=3)
        at /home/sigma/mortene/code/coin-head/src/draggers/SoDragger.cpp:179
    #13 0x407dbbb6 in SoTransformBoxDragger::~SoTransformBoxDragger (
        this=0x80a2b70, __in_chrg=3)
        at /home/sigma/mortene/code/coin-head/src/draggers/SoTransformBoxDragger.cpp:216
    [snip]
    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---


    20020821 mortene.

    UPDATE 20021010 mortene: pederb fixed a bug that seems to be
    caused by the same error as this one. The bug was never really
    *understood*, though, which seems dangerous.. see the FIXME code
    comment in SoChildList::remove().

    UPDATE 20021014 rolvs: I tried to reintroduce the bug by undoing
    the change done by pederb as described in SoChildList::remove()
    FIXME. I was not able to reproduce the described effect. I'm
    investigating this further, as there seem to be some gravel in the
    list-machinery. (See FIXME in SoChildList::insert)

=====================================================================

021 SoGetBoundingBoxAction can be made to fail when applied to a path.

    The erroneous behavior can be reproduced with the following code:

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---
    #include <Inventor/SoInput.h>
    #include <Inventor/actions/SoBoxHighlightRenderAction.h>
    #include <Inventor/actions/SoGetBoundingBoxAction.h>
    #include <Inventor/actions/SoSearchAction.h>
    #include <Inventor/nodes/SoPerspectiveCamera.h>
    #include <Inventor/nodes/SoSelection.h>
    #include <Inventor/nodes/SoSeparator.h>

    const char scene[] ="#Inventor V2.1 ascii\n\n
    DEF ROOT Separator {
      Transform {
        rotation	1 0 0  1.5708
        center	4 8 12
      }

      DEF CUBESEP Separator {
        DEF CUBE Cube { }
      }
    }";


    int main( int argc, char ** argv )
    {
      SoDB::init();

      SoInput in;
      in.setBuffer((void *)scene, strlen(scene));
      SoSeparator * root = SoDB::readAll(&in);
      root->ref();
      assert(root);

      SoNode * node = SoNode::getByName(SbName("CUBE"));
      assert(node);

      SoSearchAction sa;
      sa.setNode(node);
      sa.apply(root);

      SoPath * path = sa.getPath();
      assert(path);
      path->ref();

      SoGetBoundingBoxAction * bboxaction = new SoGetBoundingBoxAction(SbViewportRegion());

      fprintf(stdout, "SoGetBoundingBoxAction::apply(SoNode *):\n");
      bboxaction->apply(root);
      bboxaction->getXfBoundingBox().print(stdout); fprintf(stdout, "\n");

      fprintf(stdout, "\n\n");

      fprintf(stdout, "SoGetBoundingBoxAction::apply(SoPath *):\n");
      bboxaction->apply(path);
      bboxaction->getXfBoundingBox().print(stdout); fprintf(stdout, "\n");

      path->unref();
      delete bboxaction;
      root->unref();
      return 0;
    }
    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---

    The code first applies an SoGetBoundingBoxAction to the root node
    and then to a path from the root node to the cube node. Both runs
    should produce the same result, but the boundingbox calculated on
    the path-run comes out wrong.

    The bug has something to do with the SoTransform node that is part
    of the path. If the rotation is removed, it works. If the center
    shift is removed, it works. If both are left in, it bugs.

    20020822 mortene. (discovered by kintel.)

    UPDATE 20021015 mortene: see also bug #037, which might have the
    same cause. The code that reproduces that problem is also simpler
    than the code above.

=====================================================================

022 Sub-optimal bounding box calculations.

    The fairly simple scenegraph below results in a rather sub-optimal
    bounding box being calculated. For a good view of how it is, use
    the SoGuiExamples/engines/computexfbbox example.

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---
    #Inventor V2.1 ascii
    
    Separator {
       LightModel { model BASE_COLOR }
       
       Cube { height 5 }
    
       Separator {
          Rotation { rotation 1 0 0  0.7854 }
          Cube { }
       }
    
       Rotation { rotation 2 3 9  1.5708 }
       Cube { height 4 }
    }
    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---

    (Note that this scenegraph does not show a _grave_ bbox error. I
    prioritized getting it as small as possible while still
    demonstrating that there *is* an error. I have the original
    scenegraph which I constructed this from, where the bbox is _way_
    off.)

    UPDATE 20020830 mortene: I used SGI Inventor to check both the
    boundingbox of the minimal case above and the larger scene where
    it comes out fairly sub-optimal for us -- and the original SGI
    Inventor doesn't make any tighter fit than we are. So there might
    be something fundamental about the case above which makes it
    impossible to have SbXfBox3f.extendBy(SbXfbox3f) come out with a
    perfect fit?  Need to investigate.

    20020826 mortene.

=====================================================================

024 This scenegraph causes a nasty bounding box calculation error:

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---
    #Inventor V2.1 ascii
    
    Separator {
       Translation { translation 2 0 0 }
       Separator {
          TransformSeparator {
             Translation { translation 0 0.25 0 }
             Translation { translation 0 -0.25 0 }
          }
          Sphere {  }
       }
    }
    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---

    20020910 mortene.

=====================================================================

025 Import hangs on invalid scenegraph. This reproduces the problem:

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---
    #VRML V2.0 utf8
    
    Group {
       children [
          *
       ]
    }
    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---

    The '*' character can be replaced by any character not valid in
    identifier names, and the bug will still be present.

    Should of course never hang, but rather spit out an error message
    and abort the import process.

    20020911 mortene.

=====================================================================

026 Bounding box calculation: the bbox for the Barcelona.iv model is
    _very_ sub-optimal. (SGI Inventor seems to make a perfect fit.)

    Update, some further investigations made: the bug disappears if we
    remove the invalid face (there are two "-1" in a row in the
    coordIndex field). Bbox-calculation code should match the
    rendering code in what action to take when detecting this case, so
    bboxes matches the geometry that actually gets rendered.

    20020915 mortene.

=====================================================================

027 Timer queue management is incorrect
    This example should start chiming in once every fourth second
    after a delay of two seconds.  The first timer callback at 
    baseTime is not executed.

    #include <Inventor/SoDB.h>
    #include <Inventor/sensors/SoTimerSensor.h>
    #include <Inventor/Qt/SoQt.h>
    #include <stdio.h>

    void
    sensorCB(void * data, SoSensor * sensor) {
      printf("timer callback: %s\n", SbTime::getTimeOfDay().format().getString());
    }

    int
    main(int argc, char ** argv)
    { 
      SoQt::init("test");
      printf("init: %s\n", SbTime::getTimeOfDay().format().getString());
      SoTimerSensor * sensor = new SoTimerSensor(sensorCB, NULL);
      sensor->setInterval(2.0);
      sensor->setBaseTime(SbTime::getTimeOfDay() + SbTime(4.0));
      sensor->schedule();
      SoQt::mainLoop();
    }

    The "obvious" fix you'll find in in SoTimerSensor::reschedule()
    doesn't solve the problem, so it hasn't been applied.

    20020916 larsa.

    UPDATE: This depends on how you entepret the interface of the
    SoTimerSensor (and SoSensor). If you don't set the base time, you
    expect the sensor to start ticking obj->getInterval() after
    creation. (e.g. the base time is the time the object was
    created). In view of this, the example behaves as expected: It
    sets a base time, and starts ticking obj->getInterval() after the
    base time. In the code abowe, the first tick happens as expected
    aproximately six seconds after init, which equals (creation
    time+4.0) + getInterval().

    The actuall bug is, in my view, that the timer drifts when the
    base time is not set: It should be unnecessary to do so to prevent
    drift. It is possible to both remove the drift and simplify the
    code. (in an upcoming patch). 20021122 rolvs

    UPDATE: Don't try to interpret anything on your own - we have a
    reference implementation called SGI Inventor to be compatible
    with.  1)  The first chime should come after two seconds, as is
    done in SGI Inventor.  2)  When basetime is not set, the timer
    should drift as a side-effect of being rescheduled first after the
    timer trigger callback has been executed.  20021122 larsa

=====================================================================

028 So[SM]FString I/O problem
    " characters in strings aren't backslash-quoted when exported to
    file.  This causes the fields to get another value when it is
    read in again.

    This indicates that there is a general problem with not backslash-
    quoting string characters that need quoting, or maybe octal
    representation (if that is a valid string character representation).

    Related to this, the string reader doesn't jump in and out of
    quoted-string-mode when it encounters unquoted "-characters that
    open or close strings in the middle of the string.  I'm not sure
    if what's the correct behaviour is specified in any file format
    specification though - maybe the VRML1/VRML97 specs?.  If not,
    SGI Inventor would serve as the reference implementation on this
    issue.

    SoAsciiText * text = new SoAsciiText;
    text->string.set1Value(0, "\"quoted string\"");
    writeaction.apply(text);

    When read in again, this is read in as the two strings "quoted" and
    "string\"\"," - the last , coming from the multi-field separator,
    I guess.

    I would expect the last to be just "string" if the quoted-string-mode
    switching worked like in the Bourne shell where you can write
    h""ey" yo"u to produce the string "hey you".  The C string syntax
    would perhaps be more natural to compare with - there this kind of
    stuff isn't allowed at all.
    
    20020923 larsa.

=====================================================================

029 SoSFEnum / SoMFEnum / SoSFBitMask / SoMFBitMask can't be used for
    SoUnknownNode. The following will not import properly in Coin, but
    rather elicit a read error message:

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---
    #Inventor V2.1 ascii
    
    MarkerKit {
       fields [ SFEnum outerShape ]
       outerShape 0
    }
    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---

    The error message is:

        Coin read error: no mappings available for SoSFEnum field
        outerShape

    The reason for this problem is that the import code expects to use
    an SoSFEnum field that has been set up with a full set of enum
    values <-> names mappings. This is not the case for SoUnknownNode
    fields.

    What should be done about this is probably to be more "slack"
    about allowing SoSFEnum et al to be used _without_ name mappings
    (at least in certain contexts).

    Consider this bug a low priority item.

    20020923 mortene.

=====================================================================

030 Running larsa's 'iv2scenegraph' tool (from SmallChange/test-code/)
    on the good old windmill.iv model (and probably others aswell)
    makes it output a PNG that is "skewed".

    Most likely an SoOffscreenRenderer bug (perhaps with the unlimited
    buffer size functionality), but more investigation is needed.

    20020924 mortene.

    UPDATE 20021121 larsa:  I think Øystein has fixed the skewing
    problem now - don't know if he has been instructed to update this
    file when fixing bugs?  Anyways, he has other problems with the
    offscreen renderer he is working on.

=====================================================================

031 Setting up the alpha channel for the offscreen renderer doesn't
    consistently (between hosts) produce a transparent background when
    using setComponents(SoOffscreenRenderer::RGB_TRANSPARENCY).  It
    works at home on my Debian Linux w/ GeForce4MX440 with the 3123
    NVIDIA GLX sources, but not at work with whatever gfx system I
    have there.

    Index: src/misc/SoOffscreenGLXData.icc
    ===================================================================
    RCS file: /export/cvsroot/Coin/src/misc/SoOffscreenGLXData.icc,v
    retrieving revision 1.17
    diff -u -r1.17 SoOffscreenGLXData.icc
    --- src/misc/SoOffscreenGLXData.icc     19 Sep 2002 10:08:04 -0000      1.17
    +++ src/misc/SoOffscreenGLXData.icc     27 Sep 2002 08:50:02 -0000
    @@ -199,6 +199,8 @@
         attrs[pos++] = 4;
         // FIXME: won't get an alpha channel in the context unless we also
         // request a particular ALPHA bitsize. 20020605 mortene.
    +    attrs[pos++] = GLX_ALPHA_SIZE;
    +    attrs[pos++] = 4;
       }
       attrs[pos++] = None;
       return pos;

    20020927 larsa.

    UPDATE 20020927 mortene: this could simply be caused by the GLX /
    X11 drivers lacking support for any alpha-enabled visuals
    (according to spec, it is not guaranteed that any such visual is
    available). Anyway, the right way to solve this problem is to 1)
    write our own weight-function for X11 visuals (like it's been done
    for MSWin visuals in SoWin's SoWinGLWidget.cpp), for better
    control of the selection process. Then 2) warn the user if we
    can't get hold of any visual capable of all requested features.

    UPDATE 20021022 larsa: this was the case - old XFree3 with old
    Mesa does not support alpha for offscreen rendering.

    UPDATE 20021121 larsa: The offscreen renderer GL context creation
    is nevertheless bogus (with GLX at least), and should be fixed so
    the best possible context is created.

=====================================================================

032 The following lineset will render in SGI Inventor, but asserts
    in Coin (don't know what happens in non-debug builds).

    #Inventor V2.1 ascii

    Separator {
      Coordinate3 {
        point [ 0 0 0, 1 0 0, 2 0 0, 3 0 0 ]
      }
      IndexedLineSet {
        coordIndex [
          0, 1, -1,
          -1, # the offending empty line segment
          2, 3, -1
        ]
      }
    }

    In the long term, an optimized and a robust rendering method for
    this and related shapes should be implemented, and selected at
    run-time by the robust rendering method.

    20020927 larsa.

    UPDATE 20021010 mortene: fixed now?
    
=====================================================================

033 Some of the default geometry files for dragger geometries uses an
    SoDrawStyle::lineWidth > 1.0. This can be outside the legal range
    of the OpenGL implementation, which only guarantees that 1.0 can
    be used. (We have indeed received at least one problem report due
    to this.)

    I'm working on a solution for this, which involves setting up some
    new global fields which contains the legal ranges of glLineWidth()
    and glPointSize(). From .iv-files, one can then connect to these
    global fields.

    20020930 mortene.

=====================================================================

034 The rendering performance when loading
    Coin/data/draggerDefaults/transformerDragger.iv into an
    examinerviewer seems disproportionately bad versus what one would
    expect (it doesn't look like it contains all that much geometry).

    Should investigate why this happens. (Do a profile run, perhaps?)

    This is a high priority task, which is probably hard enough to
    debug that it should be left to pederb.  ;-)

    Found and reported on coin-discuss by Coin-user Martin Vogt.

    A few interesting findings after some fiddling with the .iv-file
    in question:

        - SGI Inventor renders the geometry of the file with a lot
          better performance than Coin-2

        - turning off transparency in all materials doesn't help

        - blanking out all materials in general doesn't help

        - changing TRANSFORMER_ROTATOR_MARKER to be an SoLabel instead
          of an SoSphere speeds up rendering *dramatically* (fps goes
          from ~7 to ~50 on my home machine), even though from a quick
          look I believe that only removes 18 spheres from the scene

        - removing all SoIndexedFaceSet instances alone doesn't seem
          to help much (fps stays about the same)

        - removing all SoIndexedLineSet instances alone doesn't seem
          to help much (fps stays about the same)

        - removing all SoIndexedFaceSet and SoIndexedLineSet instances
          *together* causes a jump in fps approximately equal to the
          one when removing the spheres

    20021007 mortene.

=====================================================================

035 Possible SoJackManip misbehavior.

    We have a report from an external Coin user (Julien de Siebenthal)
    that the translation components of the transformation matrix of an
    SoJackManip will be modified even when we only *rotate* the
    jack-manipulator.

    Investigate if this is indeed the case by writing a minimal
    test-case.

    20021008 mortene.

    UPDATE: Performing a rotation changes only the 3x3 rotation matrix
    (i in [0,3], j in [0,3]). Are there any descriptions of how Julien
    produced this error in the first place? I have not reproduced the
    full interaction loop, only a simple
    'rotate-translate-rotate-translate' directly on the manip and
    verified that the results are healthy. 20021111 rolvs

=====================================================================

036 This program will hit an assert if we interact with the
    SoTrackballDragger at the same time as it is removed from the
    scenegraph:

    ----8<---- [snip] ---------8<---- [snip] ---------8<---- [snip] --
    #include <Inventor/Qt/SoQt.h>
    #include <Inventor/Qt/viewers/SoQtExaminerViewer.h>
    #include <Inventor/nodes/SoNodes.h>
    #include <Inventor/sensors/SoTimerSensor.h>
    #include <Inventor/draggers/SoTrackballDragger.h>
    
    static void deleteObjectCB(void *d, SoSensor *sensor)
    {
      SoSeparator * root = (SoSeparator *)d;
      if (root->getNumChildren() > 0) { root->removeChild(0); }
    
      SoNode * n = new SoTrackballDragger;
      root->addChild(n);
    }
    
    int
    main(int argc, char **argv)
    {
      QWidget * mainWindow = SoQt::init(argv[0]);
    
      SoSeparator * root = new SoSeparator;
      root->ref();
    
      SoTimerSensor * sensor = new SoTimerSensor(deleteObjectCB, root);
      sensor->setInterval(1);
      sensor->schedule();
    
      SoQtExaminerViewer *viewer = new SoQtExaminerViewer(mainWindow);
      viewer->setSceneGraph(root);
      viewer->viewAll();
      viewer->show();
      SoQt::show(mainWindow);
      SoQt::mainLoop();
    
      delete sensor;
      delete viewer;
      root->unref();
    
      return 0;
    }
    ----8<---- [snip] ---------8<---- [snip] ---------8<---- [snip] --

    Should of course be robust and handle this properly without
    crashing, even though this is a rather obscure problem.

    (Consider this bug a low-priority item.)

    I did some quick checking on a few other draggers, and they seem
    to handle getting destructed while they are interacted
    with. Should check all of them after fixing this
    SoTrackballDragger bug, though.

    20021011 mortene.

=====================================================================

037 SoGetBoundingBoxAction fails on SoPath.

    Reproduce with this stand-alone example code (hit 'esc' to go into
    selection mode, then click the sphere):

    ----8<---- [snip] ---------8<---- [snip] ---------8<---- [snip] --
    #include <Inventor/Qt/SoQt.h>
    #include <Inventor/Qt/viewers/SoQtExaminerViewer.h>
    #include <Inventor/actions/SoBoxHighlightRenderAction.h>
    #include <Inventor/actions/SoGetBoundingBoxAction.h>
    #include <Inventor/nodes/SoSelection.h>
    #include <Inventor/nodes/SoSeparator.h>
    
    SoSelection *selection = NULL;
    SoQtExaminerViewer * examinerviewer =NULL;
    
    const char * scenetxt = "#Inventor V2.1 ascii\n\n"
    "\n"
    "Separator {\n"
    "    Translation {\n"
    "      translation 0 7 0\n"
    "    }\n"
    "    Material {\n"
    "      diffuseColor 1 0 0\n"
    "    }\n"
    "    Sphere {\n"
    "       radius 1\n"
    "    }\n"
    "}\n";
    
    
    void made_selection(void *userdata, SoPath *path)
    {
      SoGetBoundingBoxAction bba(examinerviewer->getViewportRegion());
      bba.apply(path);
    
      SbBox3f bbox = bba.getBoundingBox();
      SbVec3f center = bba.getCenter();
      printf("Object center: (%f %f %f)\n",center[0], center[1], center[2]);
      float xs, ys, zs;
      bbox.getSize(xs, ys, zs);
      printf("Object size: (%f %f %f)\n", xs, ys, zs);
    
      selection->touch();
    }
    
    int main(int argc, char *argv[])
    {
      QWidget * win = SoQt::init(argv[0]);
    
      SoInput in;
      in.setBuffer((void *)scenetxt, strlen(scenetxt));
      SoSeparator * root = SoDB::readAll(&in);
    
      selection = new SoSelection;
      selection->ref();
    
      selection->addChild(root);
      selection->addSelectionCallback(made_selection, NULL);
    
      examinerviewer = new SoQtExaminerViewer( win );
      examinerviewer->setSceneGraph(selection);
      SoBoxHighlightRenderAction *bhra = new SoBoxHighlightRenderAction;
      examinerviewer->setGLRenderAction(bhra);
      examinerviewer->show();
    
      SoQt::show(win);
    
      SoQt::mainLoop();
    
      selection->unref();
      return 0;
    }
    ----8<---- [snip] ---------8<---- [snip] ---------8<---- [snip] --

    The cause of this bug might be the same as for bug #021.

    20021015 mortene. Found by a course student of Kintel & Kyrah in
    Sri Lanka. :-}

=====================================================================

038 One particular .iv-file with SoIndexedNurbsSurface node causes
    crash on rendering.

    This scenegraph causes any Coin viewer to crash on first attempt
    at rendering:

    ----8<---- [snip] ---------8<---- [snip] ---------8<---- [snip] --
    #Inventor V2.1 ascii
    
    Separator {
    
       Texture2 { image 2 2 4 0xff0000ff 0x00ff00ff 0x0000ffff 0xff00ffff }
    
       Coordinate3 {
          point [
           0 0 0,
           0 0 0,
           -4.5 -2.0  8.0,
           -2.0  1.0  8.0,
           2.0 -3.0  6.0,
           5.0 -1.0  8.0,
           -3.0  3.0  4.0,
           0.0 -1.0  4.0,
           1.0 -1.0  4.0,
           3.0  2.0  4.0,
           -5.0 -2.0 -2.0,
           -2.0 -4.0 -2.0,
           2.0 -1.0 -2.0,
           5.0  0.0 -2.0,
           -4.5  2.0 -6.0,
           -2.0 -4.0 -5.0,
           2.0  3.0 -5.0,
           4.5 -2.0 -6.0
          ]
       }
    
       TextureCoordinate2 {
          point [
           0 0,
           0 0,
           0 0,
           -4.5 8.0,
           -2.0 8.0,
           2.0 6.0,
           5.0 8.0,
           -3.0 4.0,
           0.0 4.0,
           1.0 4.0,
           3.0 4.0,
           -5.0 -2.0,
           -2.0 -2.0,
           2.0 -2.0,
           5.0 -2.0,
           -4.5 -6.0,
           -2.0 -5.0,
           2.0 -5.0,
           4.5 -6.0
          ]
       }
    
    
       IndexedNurbsSurface {
          numUControlPoints 4
          numVControlPoints 4
          uKnotVector [ 0, 0, 0, 0, 1, 1, 1, 1 ]
          vKnotVector [ 0, 0, 0, 0, 1, 1, 1, 1 ]
          numSControlPoints 4
          numTControlPoints 4
          sKnotVector [ 0, 0, 0, 0, 1, 1, 1, 1 ]
          tKnotVector [ 0, 0, 0, 0, 1, 1, 1, 1 ]
          coordIndex [ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 ]
          textureCoordIndex [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18 ]
       }
    }
    ----8<---- [snip] ---------8<---- [snip] ---------8<---- [snip] --

    If we remove all texture-related stuff in the file, it will no
    longer crash.

    Investigate to find the exact cause. If it's our bug, fix. If it's
    a bug in the file, try to make code more robust (at least insert
    an assert(), but preferably handle with just a warning and no
    crash).

    20021015 mortene.

=====================================================================

039 VRML97 file with PROTO use crashes on import.

    This file will cause import through SoDB::readAll() to crash Coin:

    ----8<---- [snip] ---------8<---- [snip] ---------8<---- [snip] --
    #VRML V2.0 utf8
    
    PROTO Surface [
     exposedField SFNode  coord      NULL 
     field        MFVec3f point      []  
    ]
    {
       Shape {
          geometry IndexedFaceSet {
             coord      IS coord   
             coord DEF SurfaceCoord Coordinate { point IS point }
          }
       }
    }
    
    Surface {
       coord Coordinate {              
          point [ 0 0 0 ]
       }   
    }
    ----8<---- [snip] ---------8<---- [snip] ---------8<---- [snip] --

    (The file is nonsensical, but that is because it's been cut down
    into the minimal size that still exposes the bug.)

    The call-stack backtrace looks like this:

    ----8<---- [snip] ---------8<---- [snip] ---------8<---- [snip] --
    Program received signal SIGSEGV, Segmentation fault.
    [Switching to Thread 1024 (LWP 9048)]
    0x40966bd5 in SoProto::connectISRefs (this=0x80a5670, inst=0x80a69e8, src=0x80a5d20, dst=0x80b7038) at /home/sigma/mortene/code/coin-head/src/misc/SoProto.cpp:613
    613           dstfield = node->getField(fieldname);
    (gdb) bt
    #0  0x40966bd5 in SoProto::connectISRefs (this=0x80a5670, inst=0x80a69e8, src=0x80a5d20, dst=0x80b7038) at /home/sigma/mortene/code/coin-head/src/misc/SoProto.cpp:613
    #1  0x40966803 in SoProto::createInstanceRoot (this=0x80a5670, inst=0x80a69e8) at /home/sigma/mortene/code/coin-head/src/misc/SoProto.cpp:540
    #2  0x40965353 in SoProto::createProtoInstance (this=0x80a5670) at /home/sigma/mortene/code/coin-head/src/misc/SoProto.cpp:156
    #3  0x4091c617 in SoBase::createInstance (in=0xbffff9f8, classname=@0xbffff8fc) at /home/sigma/mortene/code/coin-head/src/misc/SoBase.cpp:1673
    #4  0x4091c1de in SoBase::readBaseInstance (in=0xbffff9f8, classname=@0xbffff8fc, refname=@0xbffff8ac, base=@0xbffff974)
        at /home/sigma/mortene/code/coin-head/src/misc/SoBase.cpp:1599
    #5  0x4091c0e9 in SoBase::readBase (in=0xbffff9f8, classname=@0xbffff8fc, base=@0xbffff974) at /home/sigma/mortene/code/coin-head/src/misc/SoBase.cpp:1554
    #6  0x4091b099 in SoBase::read (in=0xbffff9f8, base=@0xbffff974, expectedtype=
          {index = 5, static typelist = 0x8079cb8, static typedatalist = 0x8079cd0, static typedict = 0x8079cf0}) at /home/sigma/mortene/code/coin-head/src/misc/SoBase.cpp:1052
    #7  0x409578e9 in SoDB::read (in=0xbffff9f8, base=@0xbffff974) at /home/sigma/mortene/code/coin-head/src/misc/SoDB.cpp:555
    #8  0x4095792a in SoDB::read (in=0xbffff9f8, rootnode=@0xbffff9b8) at /home/sigma/mortene/code/coin-head/src/misc/SoDB.cpp:573
    #9  0x40957aa6 in SoDB::readAll (in=0xbffff9f8) at /home/sigma/mortene/code/coin-head/src/misc/SoDB.cpp:650
    #10 0x0804973c in get_scene_graph (argc=2, argv=0xbffffac4) at computils.cpp:131
    #11 0x080492eb in main (argc=2, argv=0xbffffac4) at examinerviewer.cpp:39
    ----8<---- [snip] ---------8<---- [snip] ---------8<---- [snip] --

    We should of course never crash when importing any .iv or .wrl
    file. If the file is faulty, we need to detect this and handle in
    a robust manner by using SoReadError::post() and aborting the
    import process.

    20021015 mortene.

=====================================================================

040 setRealtimeInterval() doesn't work

    The interval value is set correctly, but the realTime field updates
    follows another speed...

    #include <Inventor/Qt/SoQt.h>
    #include <Inventor/Qt/viewers/SoQtExaminerViewer.h>

    #include <Inventor/SoDB.h>
    #include <Inventor/nodes/SoSeparator.h>
    #include <Inventor/nodes/SoMaterial.h>
    #include <Inventor/nodes/SoText3.h>
    #include <Inventor/nodes/SoPerspectiveCamera.h>
    #include <Inventor/nodes/SoDirectionalLight.h>

    #include <stdio.h>

    int
    main(int , char **argv)
    {  
       QWidget * myWindow = SoQt::init(argv[0]);
       if (myWindow == NULL) exit(1);
    
       SoSeparator *root = new SoSeparator;
       root->ref();
    
       SoPerspectiveCamera *myCamera = new SoPerspectiveCamera;
       root->addChild(myCamera);
       root->addChild(new SoDirectionalLight);
       SoMaterial *myMaterial = new SoMaterial;
       myMaterial->diffuseColor.setValue(1.0, 1.0, 1.0);
       root->addChild(myMaterial);
    
       SoText3 *myText = new SoText3;
       root->addChild(myText);
       myText->string.connectFrom(SoDB::getGlobalField("realTime"));
    
       //-----------------------------------------------------------
       SoDB::setRealTimeInterval(SbTime(10.0f));
       fprintf(stderr, "%s\n", SoDB::getRealTimeInterval().format().getString());
       //-----------------------------------------------------------
    
       SoQtExaminerViewer *myRenderArea = new SoQtExaminerViewer(myWindow);
       myCamera->viewAll(root, myRenderArea->getSize());
       myRenderArea->setSceneGraph(root);
       myRenderArea->setTitle("Date & Time");
       myRenderArea->show();
    
       SoQt::show(myWindow);

       SoQt::mainLoop();
       return 0;
    }

=====================================================================

041 Circular field connections not always handled.

    Circular field connections are legal, but the following example
    shows off a case where it fails (just build and run to see how):

    ----8<---- [snip] ---------8<---- [snip] ---------8<---- [snip] --
    #include <Inventor/SoDB.h>
    #include <Inventor/nodes/SoCone.h>
    #include <Inventor/nodes/SoMaterial.h>
    #include <Inventor/nodes/SoSeparator.h>
    #include <Inventor/engines/SoInterpolateVec3f.h>
    #include <Inventor/nodes/SoTranslation.h>
    #include <Inventor/engines/SoCompose.h>
    
    int main(int argc, char *argv[])
    {
      SoDB::init();
    
      SoSeparator *root = new SoSeparator;
      root->ref();
    
      SoSeparator *test = new SoSeparator;
      SoTranslation *redball = new SoTranslation;
      test->addChild(redball);
    
      SoSeparator *scene = new SoSeparator;
      SoMaterial *mat = new SoMaterial;
      scene->addChild(mat);
    
      root->addChild(test);
      root->addChild(scene);
    
      SoDecomposeVec3f *dv = NULL;
      SoComposeVec3f *cv = NULL;
      SoInterpolateVec3f *interpred = NULL;
      
      dv = new SoDecomposeVec3f;
      interpred = new SoInterpolateVec3f;
      
      interpred->input0.setValue(0.0, -0.5, 0.0);
      interpred->input1.setValue(0.0, 0.5, 0.0);
      interpred->alpha.connectFrom(&dv->x);
      redball->translation.connectFrom(&interpred->output);
      
      cv = new SoComposeVec3f;
      cv->ref();
      cv->x.connectFrom(&dv->x);
      cv->y.connectFrom(&dv->y);
      cv->z.connectFrom(&dv->z);
      
      dv->vector.connectFrom(&mat->diffuseColor);
      mat->diffuseColor.connectFrom(&cv->vector);
    
      root->unref();
    
      return 0;
    }
    ----8<---- [snip] ---------8<---- [snip] ---------8<---- [snip] --

    (Example code from kintel.)

    Needs to analyze the code which spits out the warning and find the
    exact cause of why this is found to be problematic.

    Using circular connections for fields is pretty obscure, so
    consider this bug fairly low-priority to fix.

    20021016 mortene.

=====================================================================

043 We're writing invalid VRML97 files.

    According to spec, '+' is not allowed as a first character of
    nodes names in VRML97. But upon writing a scene graph from Coin,
    nameless nodes that are referenced from other nodes is still
    written to disk as "DEF +0", "DEF +1", etc.

    For how to fix properly, see Coin/docs/todo.txt, item #003.

    20021029 mortene, problem reported by kintel.

=====================================================================

044 Release builds on Cygwin/MSVC++ doesn't heed all configure
    options.

    Specifically, "--disable-symbols" should remove the "/Zi" option
    to cl.exe, and "--enable-optimization" should add "/O2" (or some
    such).

    20021118 mortene, problem reported by Michael Wimmer on
    coin-discuss.

    20021118 larsa - the --disable-symbols problem is fixed, and I'm
    against adding "--enable-optimization".  The users should rather
    specify the optimization options they want in CFLAGS/CXXFLAGS.

    20021121 larsa: since Autoconf automatically adds -O2, we should
    consider adding an option to remove that option, if it can be
    made to work without touching user-set CFLAGS/CXXFLAGS and only
    the autoconf-set optimization-options.  Tricky stuff...

=====================================================================
