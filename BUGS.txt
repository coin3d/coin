=====================================================================

002 Trying to parse this file causes an assert failure / crash (which
    should _never_ happen, of course, no matter how wrong the file
    is):

    ---8<-------8<-------8<-------8<-------8<-------8<-------8<----
    #Inventor V2.1 ascii

    Separator {
       TransformerDragger {
          translator1Switch Switch { }
          translator1LocateGroup LocateHighlight { }
       }
    }
    ---8<-------8<-------8<-------8<-------8<-------8<-------8<----

    => /home/mortene/code/coin-head/src/nodekits/SoBaseKit.cpp:1686:
         SbBool SoBaseKit::setPart(int, SoNode *):
         Assertion `oldIdx >= 0' failed.

    (After this has been fixed, should also try to fully export the
    internals of an unmodified SoTransformerDragger and then read it
    back in again, as the file above is a _very_ cut-down version of
    such a dump.)

    <mortene@sim.no> 20020205.

=====================================================================

003 There are seams in texturemaps on SGI Octane with "IMPACTSR"
    graphics hardware.

    Can at least be seen on the SoGuiExamples/nodes/texture
    example. Reported by Dan Stewart on coin-discuss. Cause not yet
    known. Hard to debug and fix without access to the platform in
    question.

    <mortene@sim.no> 20020205.

=====================================================================

005 Free memory read on connected SoSFEnum fields?

    This is an old problem which might have been fixed now, but we
    should check it with Valgrind: Purify used to report "Free memory
    read" when deleting SoSFEnum fields that were connected to other
    fields.

    <mortene@sim.no> 20020521.

=====================================================================

007 For the following stand-alone example, picking on the nurbscurve
    only partly works:

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---
    #include <Inventor/SoDB.h>
    #include <Inventor/SoInput.h>
    #include <Inventor/SoPickedPoint.h>
    #include <Inventor/events/SoLocation2Event.h>
    #include <Inventor/nodes/SoBaseColor.h>
    #include <Inventor/nodes/SoCone.h>
    #include <Inventor/nodes/SoCoordinate3.h>
    #include <Inventor/nodes/SoEventCallback.h>
    #include <Inventor/nodes/SoMarkerSet.h>
    #include <Inventor/nodes/SoSeparator.h>
    #include <Inventor/Qt/SoQt.h>
    #include <Inventor/Qt/viewers/SoQtExaminerViewer.h>

    SoCoordinate3 *coord;

    void mouseMoveCB(void *userData, SoEventCallback *eventCB)
    {
      const SoPickedPoint *pickP = eventCB->getPickedPoint();
      if(pickP){
        const float *xyz = pickP->getPoint().getValue();
        printf("xyz =%lf %lf %lf\n",xyz[0],xyz[1],xyz[2]);
        coord->point.setValue(xyz);
      }
    }

    const char * nurbscurve = "#Inventor V2.1 ascii\n\n"
    "Separator {"
    "   PickStyle {"
    "      style SHAPE"
    "   }"
    "   LightModel {"
    "      model BASE_COLOR"
    "   }"
    "   Coordinate3 {"
    "      point [ 1476.11 1460.84 -628.038,"
    "       1470.86 1447.8 -622.961,"
    "       1462.15 1424.9 -613.788,"
    "       1452.31 1396.07 -601.719,"
    "       1443.57 1368.74 -589.954,"
    "       1428.74 1318.74 -567.739,"
    "       1399.1 1199.31 -510.515,"
    "       1380.47 1084 -445.435,"
    "       1366.84 973.854 -378.304,"
    "       1361.86 927.129 -348.91,"
    "       1356.41 868.655 -311.219,"
    "       1351.93 814.353 -275.603,"
    "       1347.16 745.613 -229.666,"
    "       1342.98 674.034 -181.29,"
    "       1339.84 614.017 -140.592,"
    "       1336.44 546.811 -95.1583,"
    "       1331.26 446.458 -27.7185,"
    "       1321.74 299.504 68.5609,"
    "       1306.62 162.637 153.404,"
    "       1290.91 63.5896 211.906,"
    "       1276.65 -13.3307 256.203,"
    "       1255.13 -107.653 308.474,"
    "       1222.55 -219.064 367.003,"
    "       1195.21 -292.713 403.659,"
    "       1180.26 -329.3 421.348 ]"
    "   }"
    "   NurbsCurve {"
    "      numControlPoints 25"
    "      knotVector [ 0, 0, 0, 0,"
    "       0.0212654, 0.0372336, 0.0466221, 0.0653992,"
    "       0.117887, 0.239617, 0.255294, 0.302551,"
    "       0.318454, 0.354628, 0.395169, 0.43633,"
    "       0.477697, 0.498482, 0.551868, 0.649936,"
    "       0.748818, 0.781971, 0.815122, 0.876749,"
    "       0.938373, 1, 1, 1,"
    "       1 ]"
    "   }"
    "}";


    int
    main(int argc, char ** argv)
    {
      QWidget *window = SoQt::init(argv[0]);

      SoSeparator *root = new SoSeparator;

      //add a green marker to appear under cursor
      SoSeparator *marksep = new SoSeparator;
      root->addChild(marksep);
      SoBaseColor *markColor = new SoBaseColor;
      markColor->rgb.setValue(0,1,0);
      marksep->addChild(markColor);
      coord = new SoCoordinate3;
      marksep->addChild(coord);
      SoMarkerSet *mark = new SoMarkerSet;
      marksep->addChild(mark);
      mark->markerIndex=SoMarkerSet::PLUS_5_5;

      SoEventCallback *myEventCB = new SoEventCallback;
      root->addChild(myEventCB);
      myEventCB->addEventCallback(SoLocation2Event::getClassTypeId(),mouseMoveCB);

      SoInput in;
      in.setBuffer((void *)nurbscurve, strlen(nurbscurve));
      SoSeparator * nurbsep = SoDB::readAll(&in);
      assert(nurbsep);
      root->addChild(nurbsep);

      SoQtExaminerViewer * viewer = new SoQtExaminerViewer(window);
      viewer->setSceneGraph(root);
      viewer->show();
      SoQt::show(window);
      SoQt::mainLoop();
      return 0;
    }
    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---

    (Original test-code supplied by Nigel Murry.)

    Some other specifications for nurbscurves and nurbssurfaces tested
    works correctly.

    pederb has tracked this down to be likely to be caused by bugs in
    libGLU: a rendered curve is different from a tesselated curve (!).

    Hard to solve this *properly* without implementing our own
    nurbs-library. Are there any quick-fixes we could apply?

    <mortene@sim.no> 20020521.

=====================================================================

008 Bounding box calculations for SoMultipleCopy is not correct. To
    reproduce, load the following model into an examinerviewer and do
    "view all":

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---

    #Inventor V2.5 ascii

    Group {
       MultipleCopy {
          matrix [
           1 0 0 0
           0 1 0 0
           0 0 1 0
           0 0 0 1,

           1 0 0 0
           0 1 0 0
           0 0 1 0
           4 0 0 1,

           1 0 0 0
           0 1 0 0
           0 0 1 0
           -4 0 0 1,
          ]

          Cube {
          }
       }
    }

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---

    One additional hint for debugging this (or other problems related
    to bbox calculations): use the SoGuiExamples/engines/computexfbox
    example to see the exact boundaries of the bbox for a scene.

    mortene 20020604.

=====================================================================

009 The CenterballDragger is FUBAR: click and hold on the invisible
    ball with LMB and voilently drag around a bit -- the yellow axis
    markers flips out completely and we'll quickly get an
    assert. Nasty.

    Looks like this is caused by the accumulation of floating point
    calculation errors (due to low-precision). Somewhere, we should
    probably store an initial matrix / transform with absolute offsets
    instead of accumulating up a "current" matrix / transform. (This
    is just an early guess, though. It could be something else.)

    mortene 20020624.

=====================================================================

012 Buglet: the SoMaterial::shininess field is not clamped if it's >
    1.0. This causes OpenGL errors, at least with some drivers.

    (The other material field values are also likely to be able to
    cause problems like this.)

    mortene 20020625.

=====================================================================

013 Bounding box calculation of the scenegraph given below is
    sub-optimal.

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---
    #Inventor V2.1 ascii

    Separator {
       Separator {
          Cube { }

          BaseColor { rgb 1 0 0 }
          Translation { translation +4 0 0 }
          Separator {
    	 Transform {
    	    translation 0 -0.5 0
    	    rotation 0 0 1 0.78
    	    scaleFactor 0.5 2 3
    	    scaleOrientation 1 0 0 0.78
    	    center 0.5 0.5 0.5
    	 }
    	 Cube { }
          }
       }

       Translation { translation 0 +6 0 }
       Separator {
          Cube { }

          BaseColor { rgb 1 0 0 }
          Translation { translation +4 0 0 }
          Separator {
    	 Transform {
    	    translation 10 -0.5 0 ~
    	    rotation 0 0 1 0.78
    	    scaleFactor 0.5 2 3
    	    scaleOrientation 1 0 0 0.78
    	    center 0.5 0.5 0.5
    	 }
    	 Cube { }
          }
       }
    }
    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---

    A good strategy for investigating the bug is using the
    SoGuiExamples/engines/computexfbox example code to load the scene
    and view the resulting bbox.

    mortene 20020729.

=====================================================================

014 SoExtSelection with ALL_SHAPES selection doesn't always work
    properly with SoArray.

    Reproduce by running the SoGuiExamples/nodes/extselection example
    on the following scene:

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---
    #Inventor V2.1 ascii

    Array {
       numElements1 2
       separation1 3 0 0

       Cube { }
    }
    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---

    ..if you select any _one_ of the cubes, I believe it works
    correctly: the SoArray with both cubes are selected. (Or does it
    -- should perhaps the correct policy be to select only that cube?
    Unlikely, but ask Peder about his opinion.)

    But if you draw up a lasso to select _both_ cubes, _none_ are
    actually selected.

    Note that it *does* work correctly for VISIBLE_SHAPES selection.

    mortene 20020806.

=====================================================================

015 SoExtSelection doesn't always work properly with SoMultipleCopy.

    Reproduce with the following scenegraph in the
    SoGuiExamples/nodes/extselection example:

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---

    #Inventor V2.5 ascii

    Group {
       MultipleCopy {
          matrix [
           1 0 0 0
           0 1 0 0
           0 0 1 0
           0 0 0 1,

           1 0 0 0
           0 1 0 0
           0 0 1 0
           4 0 0 1,

           1 0 0 0
           0 1 0 0
           0 0 1 0
           -4 0 0 1,
          ]

          Cube {
          }
       }
    }

    ----8<--- [snip] ---------8<--- [snip] ---------8<--- [snip] ---

    With ALL_SHAPES selection, you need to select either the middle
    cube by itself, or all three cubes at the same time to get the
    correct result. Selecting any two cubes, or the side cubes by
    themselves, will _not_ make the SoMultipleCopy get selected.

    With VISIBLE_SHAPES, the behavior is slightly different: select
    any two cubes, or the middle cube by itself, or all three cubes --
    and it works. Select any of the side cubes by themselves, and
    selection fails to work.

    mortene 20020806.

=====================================================================
